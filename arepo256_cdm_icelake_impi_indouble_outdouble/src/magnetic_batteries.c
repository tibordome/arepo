/*!
 * \copyright   This file is part of the AREPO code developed by Volker Springel.
 * \copyright   Copyright (C) 2013  by Volker Springel (volker.springel@h-its.org)
 * \copyright   and contributing authors.
 *
 * \file        src/magnetic_field_from_charge_displacement.c
 * \date        02/2019
 * \author      Enrico Garaldi
 * \brief       Functions to compute the magnetic field generated by an anisotropic charge displacement.
 * \details
 *
 *
 * \par Major modifications and contributions:
 *
 * - DD.MM.YYYY Description
 */
#include "allvars.h"
#include "math.h"
#include "proto.h"

#ifdef DURRIVE_BATTERY
MyDouble f_mt_HI(double e)
{
  if(e < 13.6)
    return 0;
  else
    return (8. / 5.) * (1. - 13.6 / e);
}

MyDouble f_mt_HeI(double e)
{
  if(e < 24.6)
    return 0;
  else
    return (8. / 5.) * (1. - 24.6 / e);
}

MyDouble f_mt_HeII(double e)
{
  if(e < 54.4)
    return 0;
  else
    return (8. / 5.) * (1. - 54.4 / e);
}
#endif

#if defined(BIERMANN_BATTERY) || defined(DURRIVE_BATTERY)
void set_electron_variables_of_cells_for_magnetic_batteries(void)
{
  TIMER_START(CPU_MAG_BATTERIES);

  if(ThisTask == 0)
    printf("BIERMANN and/or DURRIVE BATTERY: Setting electron properties...\n");

  double a3inv;
  if(All.ComovingIntegrationOn)
    a3inv = 1. / (All.Time * All.Time * All.Time);
  else
    a3inv = 1.;
  double c_speed = 2.99792458e10 / All.UnitVelocity_in_cm_per_s;
  int idx, i, s, j;
  for(idx = 0; idx < TimeBinsHydro.NActiveParticles; idx++)
    {
      i = TimeBinsHydro.ActiveParticleList[idx];
      if(i < 0)
        continue;

      double nH =
          HYDROGEN_MASSFRAC * SphP[i].Density / PROTONMASS * All.UnitMass_in_g / All.HubbleParam;  // / pow(All.UnitLength_in_cm, 3);

      /*set_electron_density*/
      SphP[i].n_elec = SphP[i].Ne * nH;

#ifdef BIERMANN_BATTERY
      /*set_electron_pressure*/
      double meanweight = 4. / (3 * HYDROGEN_MASSFRAC + 1 + 4 * HYDROGEN_MASSFRAC * SphP[i].Ne);

      // MyFloat temp_times_kB = SphP[i].Utherm * All.UnitEnergy_in_cgs / All.UnitMass_in_g * GAMMA_MINUS1 * meanweight * PROTONMASS;
      MyFloat temp_times_kB = SphP[i].Utherm * GAMMA_MINUS1 * meanweight * PROTONMASS / All.UnitMass_in_g * All.HubbleParam;
      SphP[i].p_elec        = temp_times_kB * SphP[i].n_elec; /*assuming elec. follows a perfect gas law*/
#endif                                                        /* BIERMANN_BATTERY */

#ifdef DURRIVE_BATTERY
      /*set_electron_momentum_transfer*/
      for(s = 0; s < 3; s++)
        SphP[i].pdot_elec[s] = 0.0;

      for(j = 0; j < UV_BINS; j++)
        {
          MyDouble total_momentum_injection_rate = 0.0;
          total_momentum_injection_rate += SphP[i].HI * nH * mrt_sigma_HI[j] * Pelec_HI[j];
#ifdef MRT_INCLUDE_HE
          total_momentum_injection_rate += SphP[i].HeI * nH * mrt_sigma_HeI[j] * Pelec_HeI[j];
          total_momentum_injection_rate += SphP[i].HeII * nH * mrt_sigma_HeII[j] * Pelec_HeII[j];
#endif

          for(s = 0; s < 3; s++)
            SphP[i].pdot_elec[s] += total_momentum_injection_rate * SphP[i].RT_F[j][s] * 1e63 / c_speed;
        }
#endif /* DURRIVE_BATTERY */
    }
  TIMER_STOP(CPU_MAG_BATTERIES);
}

void do_magnetic_batteries_source_term(void)
{
  TIMER_START(CPU_MAG_BATTERIES);

  if(ThisTask == 0)
    printf("BEOR: Doing source term... \n");

  /* dB/dt = -c*div(n_e)/(q n_e^2) x [div(p_e) - pdot] - c/(q ne_) curl(pdot)
   *       =      -term1         x        term2      -       term3           */
  double c_speed      = 2.99792458e10 / All.UnitVelocity_in_cm_per_s;
  double sqrt_four_pi = 3.5449077018110318;
  double term1[3], term2[3], term3[3];
  // double ainv = (All.ComovingIntegrationOn ? 1.0/All.Time : 1.0);
  double e_to_internal = 1.0 / pow(All.UnitLength_in_cm * All.UnitMass_in_g, 0.5) / All.UnitVelocity_in_cm_per_s;
  int idx, i;

  for(idx = 0; idx < TimeBinsHydro.NActiveParticles; idx++)
    {
      i = TimeBinsHydro.ActiveParticleList[idx];
      if(i < 0)
        continue;

      double dt_cell = 0.5 * (P[i].TimeBinHydro ? (((integertime)1) << P[i].TimeBinHydro) : 0) *
                       All.Timebase_interval; /* half the timestep of the cell */
      if(All.ComovingIntegrationOn)
        dt_cell /= hubble_function(All.Time);

      if(SphP[i].n_elec < 1e-5)
        continue;

      for(int s = 0; s < 3; s++)
        {
          term1[s] = c_speed * SphP[i].Grad.dn_elec[s] / (ELECTRONCHARGE * e_to_internal * SphP[i].n_elec * SphP[i].n_elec);
          term2[s] = 0.0;
#ifdef BIERMANN_BATTERY
          term2[s] += SphP[i].Grad.dp_elec[s];
#endif /* BIERMANN_BATTERY */

#ifdef DURRIVE_BATTERY
          term2[s] -= SphP[i].pdot_elec[s];
#endif /* DURRIVE_BATTERY */
          term3[s] = 0.0;
        }

#ifdef DURRIVE_BATTERY
      term3[0] = c_speed / (ELECTRONCHARGE * e_to_internal * SphP[i].n_elec) *
                 (SphP[i].Grad.dpdot_elec[2][1] - SphP[i].Grad.dpdot_elec[1][2]);
      term3[1] = c_speed / (ELECTRONCHARGE * e_to_internal * SphP[i].n_elec) *
                 (SphP[i].Grad.dpdot_elec[0][2] - SphP[i].Grad.dpdot_elec[2][0]);
      term3[2] = c_speed / (ELECTRONCHARGE * e_to_internal * SphP[i].n_elec) *
                 (SphP[i].Grad.dpdot_elec[1][0] - SphP[i].Grad.dpdot_elec[0][1]);
#endif

      double dBx = (-(term1[1] * term2[2] - term1[2] * term2[1]) - term3[0]) * dt_cell * SphP[i].Volume;
      double dBy = (-(term1[2] * term2[0] - term1[0] * term2[2]) - term3[1]) * dt_cell * SphP[i].Volume;
      double dBz = (-(term1[0] * term2[1] - term1[1] * term2[0]) - term3[2]) * dt_cell * SphP[i].Volume;

      double Binternal_to_Gauss = sqrt(All.UnitMass_in_g) * All.UnitVelocity_in_cm_per_s / pow(All.UnitLength_in_cm, 1.5);

      SphP[i].BConserved[0] += dBx / sqrt_four_pi; /*sqrt(4*pi) to get to Heavyside-Lorentz*/
      SphP[i].BConserved[1] += dBy / sqrt_four_pi; /*sqrt(4*pi) to get to Heavyside-Lorentz*/
      SphP[i].BConserved[2] += dBz / sqrt_four_pi; /*sqrt(4*pi) to get to Heavyside-Lorentz*/

#ifdef MAGNETIC_BATTERIES_OUTPUT_GRADIENTS
      for(int s = 0; s < 3; s++)
        {
          SphP[i].Grad_n_elec[s] = SphP[i].Grad.dn_elec[s];
          SphP[i].Grad_p_elec[s] = SphP[i].Grad.dp_elec[s];
          for(int t = 0; t < 3; t++)
            SphP[i].Grad_pdot_elec[s][t] = SphP[i].Grad.dpdot_elec[s][t];
        }
#endif /* MAGNETIC_BATTERIES_OUTPUT_GRADIENTS */
    }

  TIMER_STOP(CPU_MAG_BATTERIES);
}

#endif /* defined(BIERMANN_BATTERY) || defined(DURRIVE_BATTERY) */
